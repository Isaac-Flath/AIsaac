# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/40_trainer.ipynb.

# %% auto 0
__all__ = ['cb_steps', 'CancelFitException', 'CancelBatchException', 'CancelEpochException', 'Callback', 'summarize_callbacks',
           'Trainer']

# %% ../nbs/40_trainer.ipynb 4
from .utils import *
from .dataloaders import *
from .models import *
from .initialization import *

from datetime import datetime, timedelta
import torchvision.transforms.functional as TF,torch.nn.functional as F
import math, time

import matplotlib.pyplot as plt
import matplotlib as mpl
import fastcore.all as fc
import torch
from torch import nn, Tensor
from datasets import load_dataset, Dataset
from torch.utils.data import DataLoader
import pandas as pd , numpy as np
from torcheval.metrics import MulticlassAccuracy,Mean
from torch.optim.lr_scheduler import ExponentialLR

import dill as pickle
from fastprogress.fastprogress import master_bar, progress_bar
import inspect
import torchinfo


# %% ../nbs/40_trainer.ipynb 11
class CancelFitException(Exception): pass
class CancelBatchException(Exception): pass
class CancelEpochException(Exception): pass

# %% ../nbs/40_trainer.ipynb 12
class Callback: order=0

# %% ../nbs/40_trainer.ipynb 13
cb_steps = ['before_fit','before_epoch', 'before_batch','predict','get_loss','before_backward','backward', 'step',
            'zero_grad','after_batch','cleanup_batch','after_epoch','cleanup_epoch','after_fit','cleanup_fit']

# %% ../nbs/40_trainer.ipynb 14
def summarize_callbacks(trainer):    
    res = pd.DataFrame(columns=['Step','Callback','Doc String'])
    callbacks = [getattr(trainer,o) for o in trainer.callbacks]
    for attr in cb_steps: 
        for callback in sorted(callbacks, key=lambda x: getattr(x, 'order')):
            callback_name = callback.__class__.__name__
            callback = getattr(trainer,callback_name)
            if getattr(callback,attr,None) is not None:
                docstring = getattr(callback,attr).__doc__
                row = pd.DataFrame([[attr,callback_name,fc.ifnone(docstring,'')],],columns=res.columns,index=[''])
                res = pd.concat([res,row])
    return res

# %% ../nbs/40_trainer.ipynb 16
class Trainer:
    def __init__(self, dls, loss_func, opt_func, model, callbacks):
        self.add_callbacks(callbacks)
        fc.store_attr(but='callbacks')
            
    @with_cbs('batch', CancelBatchException)
    def one_batch(self):
        self.run_callbacks(['predict','get_loss'])
        if self.training: self.run_callbacks(['before_backward','backward','step','zero_grad'])
    
    @with_cbs('epoch',CancelEpochException)
    def _one_epoch(self):
        for self.batch_num,self.batch in zip(self.batches,self.dl): self.one_batch()

    def one_epoch(self, training):
        self.model.train(training)
        self.dl = self.dls.train if training else self.dls.valid
        self.batches = range(len(self.dl))
        self._one_epoch()

    @with_cbs('fit', CancelFitException)
    def _fit(self,train, valid):
        for self.epoch in self.epochs: 
            if train: self.one_epoch(True)
            if valid: torch.no_grad()(self.one_epoch)(False)
    
    def fit(self, n_epochs=3, lr=1e-3, callbacks=None,train=True,valid=True):
        fc.store_attr('n_epochs,lr')
        try:
            self.add_callbacks(fc.L(callbacks))
            self.opt = self.opt_func(self.model.parameters(), self.lr)
            self.epochs = range(self.n_epochs)
            self._fit(train,valid)
        finally:
            self.callbacks = [o for o in self.callbacks if o not in [o.__class__.__name__ for o in fc.L(callbacks)]]
                                                        
    @property
    def training(self): return self.model.training
    
    def add_callbacks(self,callbacks,force=False): add_callbacks(self,callbacks,force)

    def run_callbacks(self,method_names):
        cbs = [getattr(self,o) for o in self.callbacks]
        for method_name in fc.L(method_names): run_callbacks(cbs,method_name,self)
            
    def summarize_model(self): return summarize_model(model=self.model,batch=fc.first(self.dls.train)[0])
    def summarize_callbacks(self): return summarize_callbacks(self)
